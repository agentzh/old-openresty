#
# Select.yp
#
#
%{

my (@Models, @Columns);

%}

%left 'and'
%left 'or'

%%

miniSQL: statement { print "Done!\n" }
       ;

statement: select_stmt ';'
         | select_stmt
         ;

select_stmt: 'select' pattern_list postfix_clause_list
           | 'select' pattern_list
           ;

models: model ',' models
      | model
      ;

model: IDENT { push @Models, $_[1] }
     ;

pattern_list: pattern ',' pattern_list
            | pattern
            ;

pattern: aggregate alias
       | aggregate
       | proc_call
       | column
       | '*'
       ;

aggregate: func '(' column ')'
         | func '(' '*' ')'
         ;

func: 'max'
    | 'min'
    | 'count'
    | 'sum'
    ;

proc_call: IDENT '(' parameter_list ')'
         ;

parameter_list: parameter ',' parameter_list
              | parameter
              ;

parameter: STRING
         | INTEGER
         ;

column: qualified_symbol
      | symbol { push @Columns, $_[1] }
      ;

qualified_symbol: symbol '.' symbol
                    { push @Models, $_[1]; push @Columns, $_[3] }
                ;

symbol: IDENT
      ;

alias: symbol
     ;

postfix_clause_list: postfix_clause postfix_clause_list
                   | postfix_clause
                   ;

postfix_clause: where_clause
              | group_by_clause
              | order_by_clause
              | limit_clause
              | offset_clause
              | from_clause
              ;

from_clause: 'from' models
           | 'from' proc_call
           ;

where_clause: 'where' condition
            ;

condition: disjunction
         ;

disjunction: conjunction 'or' conjunction
           | conjunction
           ;

conjunction: comparison 'and' comparison
           | comparison
           ;

comparison: column operator literal
          | column operator column
          | '(' condition ')'
          ;

operator: '>'
        | '>='
        | '<='
        | '<'
        | '<>'
        | '='
        | 'like'
        ;

literal: STRING
       | INTEGER
       ;

group_by_clause: 'group by' column_list
               ;

column_list: column ',' column_list
           | column
           ;

order_by_clause: 'order by' column_list
               ;

limit_clause: 'limit' INTEGER { delete $_[0]->YYData->{limit} }
            ;

offset_clause: 'offset' INTEGER { delete $_[0]->YYData->{offset} }
             ;

%%

#use Smart::Comments;

sub _Error {
    my ($value) = $_[0]->YYCurval;

    my $token = 1;
    ## $value
    my @expect = $_[0]->YYExpect;
    ### expect: @expect
    my ($what) = $value ? "input: \"$value\"" : "end of input";

    map { $_ = "'$_'" if $_ ne '' and !/^\w+$/ } @expect;
    my $expected = join " or ", @expect;
    _SyntaxError(1, "Unexpected $what".($expected?" ($expected expected)":''), $.);
}

sub _SyntaxError {
    my ($level, $message, $lineno) = @_;

    $message= "line $lineno: error: $message";
    die $message, ".\n";
}

sub _Lexer {
    my ($parser) = shift;

    my $yydata = $parser->YYData;
    my $source = $yydata->{source};
    #local $" = "\n";
    defined $yydata->{input} && $yydata->{input} =~ s/^\s+//s;

    if (!defined $yydata->{input} || $yydata->{input} eq '') {
        ### HERE!!!
        $yydata->{input} = <$source>;
    }
    if (!defined $yydata->{input}) {
        return ('', undef);
    }

    ## other data: <$source>
    ### data: $yydata->{input}
    ### lineno: $.

    for ($yydata->{input}) {
        s/^\s*([0-9]+)\b//s
                and return ('INTEGER', $1);
        s/^\s*('[^']*')//
                and return ('STRING', $1);
        s/^\s*(\$q\$.*?\$q)\$//
                and return ('STRING', $1);
        s/^\s*(\*|count|sum|max|min|select|and|or|from|where|delete|update|set|order by|group by|limit|offset)\b//s
                and return ($1, $1);
        s/^\s*(<=|>=|<>)//s
                and return ($1, $1);
        s/^\s*([A-Za-z][A-Za-z0-9_]*)\b//s
                and return ('IDENT', $1);
        s/^\s*(\S)//s
                and return ($1, $1);
    }
}

sub parse {
    my ($self, $sql, $params) = @_;
    open my $source, '<', \$sql;
    my $yydata = $self->YYData;
    $yydata->{source} = $source;
    $yydata->{limit} = $params->{limit};
    $yydata->{offset} = $params->{offset};

    #$self->YYData->{INPUT} = ;
    ### $sql
    @Models = ();
    @Columns = ();
    $self->YYParse( yydebug => 0 & 0x1F, yylex => \&_Lexer, yyerror => \&_Error );
    close $source;
    return {
        limit   => $yydata->{limit},
        offset  => $yydata->{offset},
        models  => [@Models],
        columns => [@Columns],
    };
}

#my ($select) =new Select;
#my $var = $select->Run;

1;

