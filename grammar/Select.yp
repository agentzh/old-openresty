#
# Select.yp
#
#
%{

my (@Models, @Columns, @OutVars, %InVals, %Defaults, $Quote);

%}

%left 'and'
%left 'or'

%%

miniSQL: statement
       ;

statement: select_stmt ';'
         | select_stmt
         ;

select_stmt: 'select' pattern_list postfix_clause_list
             { join(' ', @_[1..$#_]) }
           | 'select' pattern_list
             { join(' ', @_[1..$#_]) }
           ;

models: model ',' models
             { join(' ', @_[1..$#_]) }
      | model
      ;

model: symbol { push @Models, $_[1]; "\"$_[1]\"" }
     ;

pattern_list: pattern ',' pattern_list
                { join(' ', @_[1..$#_]) }
            | pattern
            ;

pattern: aggregate alias
       | aggregate
       | proc_call
       | column
       | '*'
       ;

aggregate: func '(' column ')'
             { join(' ', @_[1..$#_]) }
         | func '(' '*' ')'
             { join(' ', @_[1..$#_]) }
         ;

func: 'max'
    | 'min'
    | 'count'
    | 'sum'
    ;

proc_call: IDENT '(' parameter_list ')'
             { join(' ', @_[1..$#_]) }
         ;

parameter_list: parameter ',' parameter_list
                { join(' ', @_[1..$#_]) }
              | parameter
              ;

parameter: string
         | INTEGER
         ;

string: STRING  { $Quote ? $Quote->(parse_string($_[1])) : "" }
      ;

column: qualified_symbol
      | symbol { push @Columns, $_[1]; "\"$_[1]\"" }
      ;

qualified_symbol: symbol '.' symbol
                    {
                      push @Models, $_[1];
                      push @Columns, $_[3];
                      "\"$_[1]\".\"$_[3]\""
                    }
                ;

symbol: IDENT
      | VAR
          { push @OutVars, $_[1]; $InVals{$_[1]} }
      ;

alias: symbol
     ;

postfix_clause_list: postfix_clause postfix_clause_list
                        { join(' ', @_[1..$#_]) }
                   | postfix_clause
                   ;

postfix_clause: where_clause
              | group_by_clause
              | order_by_clause
              | limit_clause
              | offset_clause
              | from_clause
              ;

from_clause: 'from' models
                { join(' ', @_[1..$#_]) }
           | 'from' proc_call
                { join(' ', @_[1..$#_]) }
           ;

where_clause: 'where' condition
                { join(' ', @_[1..$#_]) }
            ;

condition: disjunction
         ;

disjunction: conjunction 'or' conjunction
            { join(' ', @_[1..$#_]) }
           | conjunction
           ;

conjunction: comparison 'and' comparison
                { join(' ', @_[1..$#_]) }
           | comparison
           ;

comparison: column operator literal
                { join(' ', @_[1..$#_]) }
          | column operator column
                { join(' ', @_[1..$#_]) }
          | '(' condition ')'
                { join(' ', @_[1..$#_]) }
          ;

operator: '>'
        | '>='
        | '<='
        | '<'
        | '<>'
        | '='
        | 'like'
        ;

literal: string
       | INTEGER
       ;

group_by_clause: 'group by' column_list
                    { join(' ', @_[1..$#_]) }
               ;

column_list: column ',' column_list
                { join(' ', @_[1..$#_]) }
           | column
           ;

order_by_clause: 'order by' column_list
                    { join(' ', @_[1..$#_]) }
               ;

limit_clause: 'limit' INTEGER
                { delete $_[0]->YYData->{limit}; join(' ', @_[1..$#_]) }
            ;

offset_clause: 'offset' INTEGER {
                 delete $_[0]->YYData->{offset}; join(' ', @_[1..$#_]) }
             ;

%%

#use Smart::Comments;

sub _Error {
    my ($value) = $_[0]->YYCurval;

    my $token = 1;
    ## $value
    my @expect = $_[0]->YYExpect;
    ### expect: @expect
    my ($what) = $value ? "input: \"$value\"" : "end of input";

    map { $_ = "'$_'" if $_ ne '' and !/^\w+$/ } @expect;
    my $expected = join " or ", @expect;
    _SyntaxError(1, "Unexpected $what".($expected?" ($expected expected)":''), $.);
}

sub _SyntaxError {
    my ($level, $message, $lineno) = @_;

    $message= "line $lineno: error: $message";
    die $message, ".\n";
}

sub _Lexer {
    my ($parser) = shift;

    my $yydata = $parser->YYData;
    my $source = $yydata->{source};
    #local $" = "\n";
    defined $yydata->{input} && $yydata->{input} =~ s/^\s+//s;

    if (!defined $yydata->{input} || $yydata->{input} eq '') {
        ### HERE!!!
        $yydata->{input} = <$source>;
    }
    if (!defined $yydata->{input}) {
        return ('', undef);
    }

    ## other data: <$source>
    ### data: $yydata->{input}
    ### lineno: $.

    for ($yydata->{input}) {
        s/^\s*([0-9]+)\b//s
                and return ('INTEGER', $1);
        s/^\s*('(?:\\.|''|[^'])*')//
                and return ('STRING', $1);
        s/^\s*(\$(\w*)\$.*?\$\2\$)//
                and return ('STRING', $1);
        s/^\s*(\*|count|sum|max|min|select|and|or|from|where|delete|update|set|order by|group by|limit|offset)\b//s
                and return ($1, $1);
        s/^\s*(<=|>=|<>)//s
                and return ($1, $1);
        s/^\s*([A-Za-z][A-Za-z0-9_]*)\b//s
                and return ('IDENT', $1);
        s/^\$(\w+)//s
                and return ('VAR', $1);
        s/^\s*(\S)//s
                and return ($1, $1);
    }
}

sub parse_string {
    my $s = $_[0];
    if ($s =~ /^'(.*)'$/) {
        $s = $1;
        $s =~ s/''/'/g;
        $s =~ s/\\n/\n/g;
        $s =~ s/\\t/\t/g;
        $s =~ s/\\r/\r/g;
        $s =~ s/\\(.)/$1/g;
        return $s;
    } elsif ($s =~ /^\$(\w*)\$(.*)\$\1\$$/) {
        $s = $2;
        return $s;
    } else {
        die "Unknown string literal: $s";
    }
}

sub parse {
    my ($self, $sql, $params) = @_;
    open my $source, '<', \$sql;
    my $yydata = $self->YYData;
    $yydata->{source} = $source;
    $yydata->{limit} = $params->{limit};
    $yydata->{offset} = $params->{offset};

    $Quote = $params->{quote};
    #$QuoteIdent = $params->{quote_ident};

    #$self->YYData->{INPUT} = ;
    ### $sql
    @Models = ();
    @Columns = ();
    %InVals = ();
    @OutVars = ();
    %Defaults = ();
    my $sql = $self->YYParse( yydebug => 0 & 0x1F, yylex => \&_Lexer, yyerror => \&_Error );
    close $source;
    return {
        limit   => $yydata->{limit},
        offset  => $yydata->{offset},
        models  => [@Models],
        columns => [@Columns],
        sql => $sql,
        vars => [@OutVars],
        defaults => {%Defaults},
    };
}

#my ($select) =new Select;
#my $var = $select->Run;

1;

