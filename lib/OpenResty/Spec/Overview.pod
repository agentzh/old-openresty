=encoding utf8

=head1 NAME

OpenResty::Spec::Overview - OpenResty overview

=head1 INTRODUCTION

OpenResty is a general-purpose RESTful web service engine for web
applications. It provides the following important functionalities for
a common nontrivial web app:

=over

=item *

(scalable) relational data storage,

=item *

SQL-based reusable views,

=item *

a REST-oriented role system for access control,

=item *

view-based RSS feeds,

=item *

user-defined actions in the RestyScript language,

=item *

captchas,

=item *

and cross-site AJAX support.

=back

=head1 Key features

=head2 Accounts

An openresty server typically distributes its data in terms of accounts,
especially when the backend is a database cluster. An account is an
atomic namespace for other OpenResty first-class objects like models
and views. (In the current Pg and PgFarm backends, accounts are actually
implemented by Pg schemas.) These objects are shared in the same account
and different accounts can have different models, views, actions, and
etc. with the same names.

Operations like creating and removing accounts are not part of the
OpenResty web service API. Basically the sysadmin uses the following
command to create an account on his server terminal:

    $ bin/openresty adduser marry

and a similar command to remove one:

    $ bin/openresty deluser marry

=head2 Roles

Multiple users can share the same set of objects in an account by logging
in as different roles. And fine-grained access control can be achieved
by specifying different sets of ACL rules for each role.

Every OpenResty account has two builtin roles throughout its lifetime:
C<Admin> and C<Public>.

The C<Admin> role always owns the most privileges and its properties and
ACL rule set are always read only. C<Public> role is always anonymous
but its ACL rule set can be modified by a role with enough privileges.

An OpenResty role with access to the Role API (such as C<Admin>) can
create new roles, remove existing roles (except the two builtin roles
explained above, of course), and modify the properties and ACL rules
of other roles or even itself. For instance, to allow the C<Public>
role to perform the request C<< GET /=/model/Post/id/<some number> >>
under the same account, the C<Admin> role could insert a corresponding
access rule to the C<Public> role's ACL rule set, like this:

    POST /=/role/Public/~/~ HTTP/1.0
    Content-Length: 45

    {"method":"GET", "url":"/=/model/Post/id/~"}

The JSON structure in the POST content specifies an ACL rule. The
tild (C<~>) character in the C<url> value serves as a wildcard which
matches "anything". So both C<GET /=/model/Post/id/1> and C<GET
/=/model/Post/id/231> are allowed to perform by the C<Public> role.

Interestingly it's also possible to grant the C<Public> role privileges
to augment its own ACL rule set in a similar way:

    POST /=/role/Public/~/~ HTTP/1.0
    Content-Length: 46

    {"method":"POST", "url":"/=/role/Public/~/~"}

=head1 Login

Every user accessing an OpenResty server must specify both its account
name and its role name unless he or she has already logged in and got
a session ID. For example, a typical HTTP request may look like this:

    GET /=/model/Post/id/3?user=agentzh.Public HTTP/1.0

In the above example, the C<user> parameter has the value
C<agentzh.Public> where C<agentzh> is the account name and C<Public>
the role name. In addition, the C<Public> role is an anonymous role,
or a C<password> or a C<captcha> parameter would be required here as
well. This authentication method is called "per-request login".

Alternatively, the user can login with his user name and MD5'd password
first so as to obtain a session ID which can be used for subsequence
requests. For example:

    GET /=/login/agentzh.Admin/5f4dcc3b5aa765d61d8327deb882cf99 HTTP/1.0

will yield an HTTP response from the OpenResty server like this:

    HTTP/1.0 200 OK
    Connection: close
    Content-Type: text/plain; charset=UTF-8
    Content-Length: 98
    Date: Mon, 21 Apr 2008 11:51:49 GMT

    {
        "success": 1,
        "session": "535F265E-0F99-11DD-B185-1A3EB9E8D9B0",
        "account": "agentzh","role":"Admin"
    }

And subsequent requests can be made by using the resulting session ID:

    GET /=/model/Post/id/3?session=535F265E-0F99-11DD-B185-1A3EB9E8D9B0

For convenience, the sample HTTP requests given throughout this document
will not specify the C<user> nor the C<session> parameter explicitly.

=head2 Models

An OpenResty model is just an abstract concept of tables found in common
relational databases. An instance of an OpenResty model could be a
blog post:

        {
            "description": "Blog post",
            "columns": [
                { "name": "title", "label": "Post title", "type":
                "text" },
                { "name": "content", "label": "Post content", "type":
                "text" },
                { "name": "author", "label": "Post author", "type":
                "text" },
                { "name": "created", "default": ["now()"],
                    "type": "timestamp (0) with time zone",
                    "label": "Post creation time" },
                { "name": "comments", "label": "Number of comments",
                    "type": "integer", "default": 0 }
            ],
        }

This is approximately the C<Post> model used in my personal blog site
L<http://blog.agentzh.org>. The rough SQL equivalence could be as follows:

    create table "Post" (
        title text,
        content text,
        author text,
        created timestamp (0) with time zone default now(),
        comments integer default 0
    )

Although the data storage backend may be truly implmented this way,
the column types and names that can be used here are well defined and
reasonably limited.

After creating a model, one can insert data via an HTTP POST request:

    POST /=/model/Post/~/~ HTTP/1.0
    Content-Length: 53

    {
        "title":"My first post",
        "content":"Blah blah blah...",
        "author":"Agent Zhang"
    }

Multiple rows can be inserted at a time as well, but there's a limit.

The model API not only offers interfaces to perform CRUD operations on
models, columns, and rows, but also gives some simple but still powerful
query functionalities. Here's an example:

    GET /=/model/Post/author/agentzh?order_by=created:desc&count=10
    HTTP/1.0

which is roughly equivalent to the following standard SQL query:

    select *
    from "Post"
    where "author" = 'agentzh'
    order by created desc
    count 10

=head2 Views

=head2 Feeds

=head2 Actions

=head2 Captchas

=head2 Cross-site AJAX

