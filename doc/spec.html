<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
       "http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>OpenAPI REST Protocol Specification [draft] - OpenAPI REST 协议白皮书（草案）</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" >
<link rel="stylesheet" type="text/css" title="pod_stylesheet" href="perl.css">

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.03,
  using Pod::Simple::PullParser v2.02,
  under Perl v5.008008 at Sat Dec 22 11:41:59 2007 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<a name='___top' class='dummyTopAnchor' ></a>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#DESIGN_GOALS'>DESIGN GOALS</a>
    <li class='indexItem indexItem2'><a href='#DESIGN_BACKGROUND'>DESIGN BACKGROUND</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#PROTOCOL_BASIS'>PROTOCOL BASIS</a>
  <li class='indexItem indexItem1'><a href='#HTTP_METHODS'>HTTP METHODS</a>
  <li class='indexItem indexItem1'><a href='#URL_SYNTAX'>URL SYNTAX</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#The_leading_%2F%3D%2F'>The leading /=/</a>
    <li class='indexItem indexItem2'><a href='#Help'>Help</a>
    <li class='indexItem indexItem2'><a href='#Login'>Login</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#(35282)(33394)(30331)(24405)'>角色登录</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Models'>Models</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#Create_Models'>Create Models</a>
      <li class='indexItem indexItem3'><a href='#Alter_Models'>Alter Models</a>
      <li class='indexItem indexItem3'><a href='#Read_Models'>Read Models</a>
      <li class='indexItem indexItem3'><a href='#Delete_Models'>Delete Models</a>
      <li class='indexItem indexItem3'><a href='#Read_records'>Read records</a>
      <li class='indexItem indexItem3'><a href='#Manipulate_Records'>Manipulate Records</a>
      <li class='indexItem indexItem3'><a href='#Namespace_and_Databases'>Namespace and Databases</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Actions'>Actions</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#Create_Actions'>Create Actions</a>
      <li class='indexItem indexItem3'><a href='#Inspect_Actions'>Inspect Actions</a>
      <li class='indexItem indexItem3'><a href='#Call_Actions'>Call Actions</a>
      <li class='indexItem indexItem3'><a href='#Remove_Actions'>Remove Actions</a>
      <li class='indexItem indexItem3'><a href='#Built-in_Actions'>Built-in Actions</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Roles'>Roles</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#(33719)(21462)(35282)(33394)(21015)(34920)'>获取角色列表</a>
      <li class='indexItem indexItem3'><a href='#(33719)(21462)(35282)(33394)(20449)(24687)'>获取角色信息</a>
      <li class='indexItem indexItem3'><a href='#(35835)(21462)(26435)(38480)(35268)(21017)'>读取权限规则</a>
      <li class='indexItem indexItem3'><a href='#(28155)(21152)(26435)(38480)(35268)(21017)'>添加权限规则</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Administration'>Administration</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#DATA_FORMAT'>DATA FORMAT</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Parameters'>Parameters</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#ERROR_HANDLING'>ERROR HANDLING</a>
  <li class='indexItem indexItem1'><a href='#GRAMMAR_FOR_miniSQL'>GRAMMAR FOR miniSQL</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>OpenAPI REST Protocol Specification [draft] - OpenAPI REST 协议白皮书（草案）</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Agent Zhang (章亦春) &#60;agentzh@yahoo.cn&#62;</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<pre>    CREATED:       Nov 19, 2007
    LAST MODIFIED: Dec 22, 2007
    VERSION:       0.07</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>本文定义了 OpenAPI 基于 REST 风格的 web service API 协议组。</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="DESIGN_GOALS"
>DESIGN GOALS</a></h2>

<ul>
<li>确保对于简单的需求，API 足够简单；同时又能满足很复杂的高级需求。
<p>"Make simple things easy, hard things possible" -- Larry Wall</p>

<p>API 应能映射到绝大部分常见的 SQL 请求语句 ，但应能阻止 SQL injection 的发生。</p>
</li>

<li>API 应该足够直观和友好，应尽量做到 DWIM (Do What I mean).</li>

<li>确保 API 能够在绝大多数支持 HTTP 1.1 和 cookie 的环境中使用。包括但不限于网页中的 Javascript, 应用程序中的 Perl, C/C++, Java, C#, VB， 以及纯命令行工具 wget 和 curl 等等。</li>

<li>来自客户的 API 访问请求应保持无状态。单个请求中应包含所有信息（除了用户身分认证可以存储在 cookie 中供反复使用以外）。</li>

<li>来自服务器的数据格式（XML，JSON，YAML）应能由客户自由控制，同时客户能指定编码(charset).</li>

<li>API 在形式上必须保持统一和一致。同时单次返回的结果中应包含足够的导航信息，帮助用户进行后续请求，以取得与之相关的其他数据。</li>

<li>出于安全性方面的考虑，数据存储应采用类似 wiki 和 Subversion 版本控制方式，应提供接口允许用户拄撤销和恢复临近一段时间的操作或数据.</li>

<li>API 应支持自省能力。用户可以通过 API 获得有关 Models, Actions, 和 API 本身的帮助信息.</li>
</ul>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="DESIGN_BACKGROUND"
>DESIGN BACKGROUND</a></h2>

<p>本 API 的设计基于美国 Best Practical 公司的 Jifty 框架中所包含的 REST Web Service 接口设计 ( <a href="http://search.cpan.org/perldoc?Jifty::Manual::TutorialRest" class="podlinkurl"
>http://search.cpan.org/perldoc?Jifty::Manual::TutorialRest</a> )。</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="PROTOCOL_BASIS"
>PROTOCOL BASIS</a></h1>

<p>我们的 API 将基于最基本的 HTTP 1.1 协议。特别地，我们将充分利用 HEAD, GET, POST, PUT, DELETE 这几种基本的 HTTP 方法 来简化我们的 API。</p>

<p>在本文中，除非特别说明，将总是假设使用 <code>http://</code> 模式。</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="HTTP_METHODS"
>HTTP METHODS</a></h1>

<p>本接口使用下列 HTTP 1.1 方法:</p>

<dl>
<dt><a name="GET"
>GET</a></dt>

<dd>
<p>一般用于查询和读取操作，类似 SQL 语言中的 <code>select</code> 语句。</p>

<dt><a name="POST"
>POST</a></dt>

<dd>
<p>一般用于新建对象和插入数据，类似 SQL 语言中的 <code>create</code> 语句和 <code>insert into</code> 语句.</p>

<dt><a name="PUT"
>PUT</a></dt>

<dd>
<p>一般用于修改对象的属性和已有的数据记录。类似 SQL 语言中的 <code>update</code> 和 <code>alter</code> 语句.</p>

<dt><a name="DELETE"
>DELETE</a></dt>

<dd>
<p>一般用于删除对象和已有的数据记录. 类似 SQL 语言中的 <code>delete</code> 和 <code>drop</code> 语句。</p>

<dt><a name="HEAD"
>HEAD</a></dt>

<dd>
<p>与 <code>GET</code> 相近，但对于返回列表型数据的读取操作而言， 仅返回第一个列表项。类似 SQL 语言中的 <code>select top 1</code>.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="URL_SYNTAX"
>URL SYNTAX</a></h1>

<p>所有的 URL 都是大小写敏感的。</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="The_leading_/=/"
>The leading <code>/=/</code></a></h2>

<p>为使我们的 API 能够在 URL 上复用已有的域名，如 <code>www.yahoo.cn</code>，同时避免污染已有的 URL 名字空间，所有的 URL 都以 /=/ 起始。</p>

<p>如果域名不存在与常规网页 URL 冲突的风险，前导 <code>/=/</code> 可省略，或替换为其他形式，比如 <code>/webservice/</code> 或者 <code>/~/</code> 之类。</p>

<p>在本文中，将总是使用 <code>/=/</code> 前导，以强调这些 URL 是特殊的（从某种意义上说），并保持一致性。</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Help"
>Help</a></h2>

<pre>    GET /=/help</pre>

<p>[猜想：该命令可以返回一个无结构的纯文本帮助，或者是有结构的帮助目录列表。]</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Login"
>Login</a></h2>

<pre>    POST /=/login</pre>

<p>登录验证，目前有两种选择：</p>

<ol>
<li>使用明文传输口令
<p>此种方法使用简单，尤其对于 wget, curl 这样的工具友好。缺点是安全性不高。</p>

<p>一种可能的方式是： GET /=/login/&#60;user_name&#62;/&#60;password&#62;</p>
</li>

<li>使用加密传输口令
<p>此种方法使用复杂，需要握手过程，以及加密库的支持。</p>

<p>POST 请求的内容需要经过加密处理。比如：</p>

<pre>    POST /=/login/&#60;user_name&#62;</pre>

<p><i>POST body</i></p>

<pre>    adsfkwk3223df23245rt3423dfds2d</pre>

<p>这里的 <code>POST body</code> 中存放着经过加密的密码.</p>

<p>XXX 具体的加密算法</p>
</li>
</ol>

<p>登录获取的 session ID 将被存储于 cookie 中，供后续请求使用。</p>

<p>[猜想： 在轻量级应用中使用明文，以降低接口使用门槛，适应普通用户。对于数据安全性高的企业级应用，使用加密传输的方法。]</p>

<p>OAuth 支持也应认真考虑：</p>

<p><a href="http://oauth.net/" class="podlinkurl"
>http://oauth.net/</a></p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="(35282)(33394)(30331)(24405)"
>角色登录</a></h3>

<p>OpenAPI 支持所谓的“角色”概念。一个 OpenAPI 用户在注册时可以定义若干个“角色”,每个“角色”的权限各不相同，而都可以单独登录，并拥有不同的密码。</p>

<p>例如注册用户 marry 可以拥有 <code>Admin</code>, <code>Reader</code>, <code>User</code> 等多种角色， 每个角色都可以单独登录。当 marry 的 <code>Reader</code> 角色登录时，使用的帐户名为 <code>marry.Reader</code>. 事实上，<code>marry</code> 在作为帐户名使用时，就相当于以 <code>marry.User</code> 角色登录，因为 <code>admin</code> 角色拥有最高的权限。</p>

<p>一个例子是：</p>

<pre>    GET /=/login/marry.Reader/myPassword</pre>

<p>有关角色的更多信息，请参见 <a href="#Roles" class="podlinkpod"
>"Roles"</a> 一节。</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Models"
>Models</a></h2>

<p>模型是一种抽象的数据库表格。它可以映射到数据库的物理表，亦可以映射到虚拟的存储结构，如果电子信箱的 inbox. 模型按创建者，可以分为内置和用户自定义两种类型。模型拥有自己细化的权限模型，如可写权限分配，以及可读权限分配。</p>

<p>所有与 Model 相关的接口，其 URL 都满足下列几种形式：</p>

<pre>    /=/model                                            操纵模型列表
    /=/model/&#60;model_name&#62;                               操纵指定的模型，名为 &#60;model_name&#62;
    /=/model/&#60;model_name&#62;/&#60;column_name&#62;                 操纵指定模型 &#60;model_name&#62; 的指定列&#60;column_name&#62;
    /=/model/&#60;model_name&#62;/&#60;column_name&#62;/&#60;column_value&#62;  操纵指定模型&#60;model_name&#62;中的数据记录，
                                                        并由 &#60;column_name&#62; 和 &#60;column_value&#62; 来定位</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Create_Models"
>Create Models</a></h3>

<pre>    POST /=/model/MyNewModel</pre>

<p>新创建的 Model 的 schema 在 POST 的 content body 中通过对应格式( 比如 JSON )的 schema 说明.</p>

<p>一个例子是：</p>

<pre>    POST /=/model/Bookmark</pre>

<p><i>POST body</i></p>

<pre>    {
        name: "Bookmark",
        description: "我的书签",
        columns:
          [
            { name: "url",   type: "string", label: "书签网址" },
            { name: "title", type: "string", label: "书签标题" },
            { name: "description", type: "string", label: "书签描述" }
          ]
    }</pre>

<p>一次 POST 请求只能指定创建单个 Model. Model 的声明包含两部分，一是模型名，即 <code>name</code> 字段，一是列声明，即 <code>columns</code> 字段。</p>

<p><code>columns</code> 字段可以为一空数组，或者完全省略，此时模型中没有任何可用列。用户可以稍后通过 POST /=/model/&#60;model name&#62;/&#60;column name&#62; 来添加新列。</p>

<p>当 <code>columns</code> 字段为空时，服务器会返回一条警告信息，例如：</p>

<pre>    {"success":1,"warning":"No 'columns' specified for model \"Foo\"."}</pre>

<p>每个模型必须提供一个非空的 <code>description</code> 属性，同时模型各列的定义必须包含 <code>label</code> 这一属性，而且必须为非空。</p>

<p>请求的 POST 内容中可以不指定模型的 <code>name</code> 属性，因为它已经出现在了请求的 URL 中，如这里的 "Bookmark". 如果用户在 JSON 数据中也指定了 <code>name</code>，则</p>

<p>模型名必须以字母开头，后跟若干字母，下划线或数字。推荐模型名总以大写字母开头，比如 <code>Bookmark</code>, <code>MyMusic</code> 等等。</p>

<p>列名必须以字母开头，后跟若干字母，下划线或数字，与模型名的命名规则相似。但不同的是，推荐列名总是由小写字母开头，例如 <code>book_name</code>, <code>gender</code>, 等等。</p>

<p>虽然服务器会存储模型名和列名的大小字，但是内部处理时是不区分大小写的。所以并不允许 <code>Bookmark</code> 和 <code>bookmark</code> 这两个 Model 同时存在。</p>

<p>任何模型都将拥有一个默认列，名为 <code>id</code>，用于在一个模型中唯一地标识某一条数据记录（或者说数据行）。若用户自己在模型中指定了 <code>id</code> 列，则服务器会将之忽略，并将给出一条警告信息。</p>

<p>默认情况下，URL 及请求数据中的非 ASCII 字符都按 UTF-8 编码处理。如若需要使用其他编码，如 GBK, Big5, 和 Latin1 的话，需要显式地通过 <code>charset</code> 参数指定，例如：</p>

<pre>    POST /=/model/Bookmark?charset=GBK</pre>

<p>任何情况下，URL 和请求数据中的编码必须一致，比如必须同为 UTF-8，或者同为 GBK.</p>

<p>具体的实现会对一个 Model 所含的字段数目和类型进行约束。</p>

<p>当模型已存在时，服务器返回出错信息，例如：</p>

<pre>    { success: 0, error:"Model \"Bookmark\" already exists." }</pre>

<p>详情请见 <a href="#ERROR_HANDLING" class="podlinkpod"
>"ERROR HANDLING"</a> 一节。</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Alter_Models"
>Alter Models</a></h3>

<dl>
<dt><a name="Change_Model_Name"
>Change Model Name</a></dt>

<dd>
<p>可以通过下面的接口修改已有模型的名字：</p>

<pre>    PUT /=/model/&#60;old_name&#62;
    { name: "&#60;new_name" }</pre>

<p>一个例子是：</p>

<pre>    PUT /=/model/Bookmark
    { name: 'MyBookmark' }</pre>

<p>如果新的模型名与已存在的另一个 Model 同名，则服务器会报错，例如：</p>

<pre>    { success: 0, error: "Model \"MyBookmark\" already exists." }</pre>

<dt><a name="Change_Model_Description"
>Change Model Description</a></dt>

<dd>
<p>可以通过下面的接口修改已有模型的描述：</p>

<pre>    PUT /=/model/&#60;model_name&#62;
    { descripton: "&#60;new_description" }</pre>

<p>修改模型的名字和描述可以放在单次 HTTP 请求中，例如下面这个例子：</p>

<pre>    PUT /=/model/Bookmark
    { name: "MyBookmark", description: "这可是我的书签哦！" }</pre>

<dt><a name="Change_Model_Columns"
>Change Model Columns</a></dt>

<dd>
<p>可以通过下面的接口修改已有模型的某一列的名字，类型，或标签：</p>

<pre>    PUT /=/model/Bookmark/title
    { name: "bookmark_name", type: "varchar(20)", label: "书签名" }</pre>

<p>一次可以只修改其中的一个或者两个属性。例如：</p>

<pre>    PUT /=/model/Bookmark/title
    { name: "bookmark_name", label: "书签名" }</pre>

<p>如果我们并不想修改 title 列的类型(type)的话。</p>

<dt><a name="Add_Model_Columns"
>Add Model Columns</a></dt>

<dd>
<p>可以通过下面的接口添加模型的列：</p>

<pre>    POST /=/model/&#60;model_name&#62;/&#60;new_column_name&#62;
    { type: "&#60;type&#62;", label: "&#60;label&#62;" }</pre>

<p>一个例子是：</p>

<pre>    POST /=/model/Bookmark/comment
    { type: "text", label: "书签评论" }</pre>

<dt><a name="Delete_Model_Columns"
>Delete Model Columns</a></dt>

<dd>
<p>可以通过下面的接口删除模型的列：</p>

<pre>    DELETE /=/model/&#60;model_name&#62;/&#60;column_name&#62;</pre>

<p>一个例子是：</p>

<pre>    DELETE /=/model/Bookmark/comment</pre>
</dd>
</dl>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Read_Models"
>Read Models</a></h3>

<dl>
<dt><a name="(26174)(31034)(27169)(22411)(21015)(34920)"
>显示模型列表</a></dt>

<dd>
<pre>    GET /=/model</pre>

<p>返回的数据为一无序列表，其内容为用户所有可见的模型的名字，以及对应的 URL。</p>

<p>一个 JSON 格式的例子为：</p>

<pre>    GET /=/model

    [
        { description: "My favorite bookmark", name: "Bookmark", src: "/=/model/Bookmark", writable: 1, readable: 1 },
        { description: "My favorite music", type: "model", name: "Music", src: "/=/model/Music", writable: 1, readable: 1 },
        { description: "My frequently accessed blog", name: "Blog", src: "/=/model/Blog", writable: 1, readable: 1 },
    ]</pre>

<p>有关结果格式的讨论，请见 <a href="#DATA_FORMAT" class="podlinkpod"
>"DATA FORMAT"</a> 一节.</p>

<p>这里的 <code>writable</code> 和 <code>readable</code> 属性标记了模型的读权限和写权限。读写权限是用户通过"角色" (Role) 来分配的。</p>

<dt><a name="(26174)(31034)(25351)(23450)(27169)(22411)(30340)_schema"
>显示指定模型的 schema</a></dt>

<dd>
<p>值得指出的是，模型的 schema 并不等同于真实的数据库物理表的 schema. 模型是一种抽象的概念。</p>

<p>在模型名的命名上，一般取为首字母大写的名词单词，如 Bookmark, Book, Music 等等， 而不像数据库表格一般取成 bookmarks, books, music 这样的形式。</p>

<pre>    GET /=/model/&#60;model name&#62;</pre>

<p>该 URL 将返回模型名为 &#60;model name&#62; 的 schema 定义。</p>

<p>一个 JSON 的例子如下：</p>

<pre>    GET /=/model/Bookmark

    {
      name: "Bookmark",
      description: "My favorite bookmark",
      columns:
        [
          { name: "id", type: "serial", src: "/=/model/Bookmark/id", writable: 1, readable: 1 },
          { name: "title", type: "string", src: "/=/model/Bookmark/string", writable: 1, readable: 1 },
          { name: "url", type: "string", src: "/=/model/Bookmark/url", writable: 1, readable: 1 },
          { name: "description", type: "string", src: "/=/model/Bookmark/description", writable: 1, readable: 1 },
        ]
    }</pre>

<dt><a name="(26174)(31034)(25351)(23450)(30340)(21015)(30340)(23450)(20041)"
>显示指定的列的定义</a></dt>

<dd>
<pre>    GET /=/model/&#60;model name&#62;/&#60;column name&#62;</pre>

<p>一个例子是：</p>

<pre>    GET /=/model/Bookmark/title</pre>

<p>返回</p>

<pre>    { name: "title", type: "string", src: "/=/model/Bookmark/string", writable: 1, readable: 1 },</pre>
</dd>
</dl>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Delete_Models"
>Delete Models</a></h3>

<dl>
<dt><a name="(21024)(38500)(25351)(23450)(30340)_Model"
>删除指定的 Model</a></dt>

<dd>
<pre>    DELETE /=/model/&#60;model name&#62;</pre>

<p>该命令将删除名为 &#60;model_name&#62; 的模型。</p>

<p>在功能上相当于下面这条 SQL 语句：</p>

<pre>    drop table &#60;model name&#62;</pre>

<dt><a name="(21024)(38500)(25152)(26377)(30340)_Model"
>删除所有的 Model</a></dt>

<dd>
<pre>    DELETE /=/model</pre>
</dd>
</dl>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Read_records"
>Read records</a></h3>

<dl>
<dt><a name="(26174)(31034)(25351)(23450)(23383)(27573)(30340)(35760)(24405)(21015)(34920)"
>显示指定字段的记录列表</a></dt>

<dd>
<pre>    GET /=/model/&#60;model name&#62;/&#60;column name&#62;/~</pre>

<p>这里的星号 <code>~</code> 是“通配符”(wildcard).</p>

<p>逻辑上相当于下面这行 SQL 语句：</p>

<pre>    select &#60;column name&#62;
    from &#60;model name&#62;</pre>

<p>注意此处以及下文所给出的 SQL 语句也并非真实的 SQL，用来解释 API URL 的语义。</p>

<dt><a name="(26174)(31034)(25351)(23450)(23383)(27573)(30340)(25351)(23450)(21462)(20540)(30340)(35760)(24405)(21015)(34920)"
>显示指定字段的指定取值的记录列表</a></dt>

<dd>
<pre>    GET /=/model/&#60;model name&#62;/&#60;column name&#62;/&#60;column value&#62;</pre>

<p>其功能上相当于下面这条 SQL 语句：</p>

<pre>    select *
    from &#60;model name&#62;
    where &#60;column name&#62;=&#60;column value&#62;</pre>

<p>一个具体的体子是：</p>

<pre>    GET /=/model/Bookmark/id/1</pre>

<p>相当于</p>

<pre>    select *
    from Bookmark
    where id = 1</pre>

<p>服务器返回的结果类似于：</p>

<pre>    [
        { id: 1, title: "Revision 34: /trunk", url: "http://svn.openfoundry.com/xulapp/trunk", description: "" }
    ]</pre>

<p>如果不希望用 <code>=</code> 执行精确匹配的话，可以通过指定 <code>op</code> 选项来指定其他运算符，包括 <code>contains</code>, <code>gt</code>, <code>ge</code>, <code>lt</code>, <code>le</code>, 和 <code>eq</code>.</p>

<p>下面是一个例子：</p>

<pre>    GET /=/model/Bookmark/title/Yahoo?op=contains</pre>

<p>近似于</p>

<pre>    select *
    from Bookmark
    where title like '%Yahoo%'</pre>

<p>典型的返回结果如下：</p>

<pre>    [
        { id: 56, title: "Yahoo News", url: "http://news.yahoo.com", description: "美国雅虎网站" },
        { id: 57, title: "Yahoo中国", url: "http://cn.yahoo.com", description: "阿里巴巴中国雅虎首页" }
    ]</pre>

<dt><a name="(25193)(23637)(26597)(35810)(35821)(27861)"
>扩展查询语法</a></dt>

<dd>
<p>通过指定 extended=1 选项，可以启用扩展查询语法。下面是几个例子：</p>

<pre>    GET /=/model/Bookmark/id/1,3,52..72?extended=1</pre>

<p>相当于下面这句 SQL 查询：</p>

<pre>    select *
    from Bookmark
    where id = 1 or id = 3 or id between 52 and 72</pre>

<p>又如：</p>

<pre>    GET /=/model/Timetable/arrival_time/18:32..20:59,5:07..8:40?extended=1</pre>

<p>相当于下面这句 SQL 查询：</p>

<pre>    select *
    from Timetable
    where arrival_time between '18:32' and '20:59'</pre>

<p>可以使用通配符 <code>*</code> 来表示没有上限或下限，例如：</p>

<pre>    GET /=/model/Person/height/1.86..~?extended=1</pre>

<p>表示选取身高在 1.86 以上的 Persion，相当于下面这句 SQL:</p>

<pre>    select *
    from Person
    where height &#62; 1.86</pre>

<p>如果要选取身高小于 1.65 的人，则可以这么写：</p>

<pre>    GET /=/model/Person/height/~..1.65?extended=1</pre>
</dd>
</dl>

<p>更高级的检索需求 (比如 table join 和 group by) 应由 <code>/=/action/ModelSearch</code> 来完成.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Manipulate_Records"
>Manipulate Records</a></h3>

<dl>
<dt><a name="(25554)(20837)(35760)(24405)"
>插入记录</a></dt>

<dd>
<pre>    POST /=/model/&#60;model name&#62;/~/~</pre>

<p>该命令用于向指定模型上传若干新记录。一个例子是：</p>

<pre>    POST /=/model/Bookmark/~/~</pre>

<p><i>POST body</i></p>

<pre>    [
        { title: "Yahoo News", url: "http://news.yahoo.com", description: "美国雅虎网站" },
        { title: "Yahoo中国", url: "http://cn.yahoo.com", description: "阿里巴巴中国雅虎首页" },
        { title: "Revision: /trunk", url: "http://svn.openfoundry.org/xulapp/trunk", description: "我的 XUL::App 项目" }
    ]</pre>

<p><i>Output</i></p>

<pre>    { success: 1, rows_affected: 3, last_row: "/=/model/Bookmark/id/3" }</pre>

<p>具体的实现会对一次插入的记录数目进行限制。</p>

<dt><a name="(20462)(25913)(35760)(24405)"
>修改记录</a></dt>

<dd>
<pre>    PUT /=/model/&#60;model name&#62;/&#60;column name&#62;/&#60;column value&#62;</pre>

<p>修改指定记录的字段值。</p>

<p>一个例子是：</p>

<pre>    PUT /=/model/Bookmark/url/yahoo?op=contains</pre>

<p><i>POST body</i></p>

<pre>    { title: "My Yahoo Home", description: "As title" }</pre>

<p>对应的伪 SQL 为：</p>

<pre>    update bookmarks
    set title = 'My Yahoo Home', description = 'As title'
    where url like '%yahoo%'</pre>

<p>[猜想：PUT 请求亦可专用于上传二进制的多媒体数据。]</p>

<dt><a name="(21024)(38500)(35760)(24405)"
>删除记录</a></dt>

<dd>
<p>用于删除指定的记录</p>

<p>一个例子是：</p>

<pre>    DELETE /=/model/Bookmark/url/yahoo?op=contains</pre>

<p>对应的伪 SQL 为：</p>

<pre>    delete from bookmarks
    where url like '%yahoo%'</pre>
</dd>
</dl>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Namespace_and_Databases"
>Namespace and Databases</a></h3>

<p>模型的名字可以写成名字空间修饰的形式，比如 <code>Foo.Bar.Baz</code>. 从逻辑上讲, <code>Foo</code> 相当于一个数据库，或者说是模型的集合。</p>

<p>[猜想: 模型检索时应提供名字空间级别上的搜索。]</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Actions"
>Actions</a></h2>

<p>"动作(Action)"是一种抽象的功能实体。典型的 Action 的例子有"网页搜索", "模型搜索", 以及"邮件发送"等等。 Action 在概念上与编程语言中的函数相近。</p>

<p>每一个 Action 都有一个界面，界面一般由若干个 parameters 组成。就像每一个 model 都由若干个 columns 组成一样。</p>

<p>Action 一般都拥有返回值, 比如“网页搜索”这个动作会返回一个结果列表，而"邮件发送"这个Action 只会返回 true 或者 false.</p>

<p>Action 亦可分为内建 Action (如 WebSearch 和 ModelSearch ) 和用户自定义 Action 两大类.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Create_Actions"
>Create Actions</a></h3>

<p>警告：这一部分是高度猜想性质。</p>

<p>用户自定义的 Action 在概念上等同于数据库中的视图(view)，并将通过 OpenAPI 自己定义的 miniSQL 语言来表达其功能.</p>

<p>miniSQL 将不支持嵌套语句，比如嵌套型 select 语句.</p>

<p>示例：</p>

<pre>    POST /=/action</pre>

<p><i>POST body</i></p>

<pre>    [
      {
        name: "My SVN bookmarks",
        body: "select * from Bookmark where url like "%svn.%" or description like "%SVN%""
      },
      {
        name: "My Yahoo bookmarks",
        body: "select * from Bookmark where url like "%yahoo%" and title like "%yahoo%""
      }
    ]</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Inspect_Actions"
>Inspect Actions</a></h3>

<pre>    GET /=/action/&#60;action name&#62;</pre>

<p>可获得指定 action 的界面</p>

<p>示例：</p>

<pre>    GET /=/action/WebSearch</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Call_Actions"
>Call Actions</a></h3>

<pre>    GET /=/action/&#60;action name&#62;/&#60;parameter1&#62;/&#60;value1&#62;?&#60;parameter2&#62;=&#60;value2&#62;&#38;&#60;parameter3&#62;=&#60;value3&#62;&#38;...</pre>

<p>以指定的参数调用 actions. 示例：</p>

<pre>    GET /=/action/WebSearch/query/Hello,world
    [
        { title: "Hello world program - Wikipedia, the free encyclopedia", url: "en.wikipedia.org/wiki/Hello_world_program", summary: "..." },
        { title: "Helloworld.com", url: "www.helloworld.com/", summary: "..." },
        { title: "...", url: "...", summary: "..." },
        ...
    ]</pre>

<p>对于无参数的 Action 调用时使用</p>

<pre>    GET /=/action/&#60;action name&#62;/dummy/nil</pre>

<p>的形式。</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Remove_Actions"
>Remove Actions</a></h3>

<pre>    DELETE /=/action/&#60;action name&#62;</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Built-in_Actions"
>Built-in Actions</a></h3>

<dl>
<dt><a name="ModelSearch"
>ModelSearch</a></dt>

<dd>
<p>ModelSearch 提供了用 MiniSQL 对 Models 进行高级查询的方式。下面是一个例子：</p>

<pre>    POST /=/action/ModelSearch/lang/miniSQL</pre>

<p><i>POST body</i></p>

<pre>    "select * from Music, Bookmark where Music.url = Bookmark.url"</pre>

<dt><a name="WebSearch"
>WebSearch</a></dt>

<dd>
<pre>    GET /=/action/WebSearch
    [
        { name: "query", type: "string" }
    ]

    GET /=/action/WebSearch/query/Hello,world
    [
        { title: "Hello world program - Wikipedia, the free encyclopedia", url: "en.wikipedia.org/wiki/Hello_world_program", summary: "..." },
        { title: "Helloworld.com", url: "www.helloworld.com/", summary: "..." },
        { title: "...", url: "...", summary: "..." },
        ...
    ]</pre>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Roles"
>Roles</a></h2>

<p>OpenAPI 通过角色 (Role) 来实现子用户和权限分配功能。 一个 OpenAPI 注册用户可以拥有多个角色，她可以通过 /=/role 这个 URL 对她的角色进行管理，其中包括添加和删除角色，对角色权限进行分配， 指定角色的登录方式（是通过口令，验证码图片，还是匿名）。</p>

<p>在 OpenAPI 中，角色对象是一种特殊的 Model，/=/role 与 /=/model 在接口上有许多相似之处。</p>

<p>每一个角色实体都被视为一个规则 Model. 所有 Model 的查询，修改， 和删除操作都同样适用于 Role.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="(33719)(21462)(35282)(33394)(21015)(34920)"
>获取角色列表</a></h3>

<pre>    GET /=/role</pre>

<p>服务器返回的是一个角色列表。每一个项目描述了对应角色的名称，描述，和 URL。 例如：</p>

<pre>  [
    { name: "Admin", description: "管理员", src: "/=/role/Admin" },
    { name: "User", description: "普通用户", src: "/=/role/User" },
    { name: "Anonymous", description: "匿名用户", src: "/=/role/Anonymous" },
    { name: "Commenter", description: "评论用户", src: "/=/role/Commenter" }
  ]</pre>

<p>其中 Admin, User, 和 Anonymous 这三个角色是 OpenAPI 用户在注册时 自动分配的，而且不能删除。用户直接使用用户名，比如 marry 登录时， 相当于使用 marry.User 帐户来登录。本文档中表的删除和修改操作都需要以 Admin 角色的权限。User 默认是没具有这些权限的。</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="(33719)(21462)(35282)(33394)(20449)(24687)"
>获取角色信息</a></h3>

<pre>    GET /=/role/&#60;role name&#62;</pre>

<p>返回一个哈希结构，其中包括角色名，角色描述，父亲角色，登录方式，等等字段。 一个典型的例子是：</p>

<pre>    GET /=/role/Admin
    {
        name: "Admin",
        description: "管理员",
        inherits: "User",
        columns: [
            { name: "method", label: "HTTP方法"},
            { name: "resource", lable: "资源名" }
        ]
    }</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="(35835)(21462)(26435)(38480)(35268)(21017)"
>读取权限规则</a></h3>

<pre>    GET /=/role/&#60;role name&#62;/&#60;column&#62;/&#60;value&#62;</pre>

<p><code>&#60;column&#62;</code> 和 <code>&#60;value&#62;</code> 的含义与 Model 的 URL 记法中的一致。</p>

<p>例如当二者同时为 <code>~</code> 时返回所有的权限规则：</p>

<pre>    GET /=/role/Commenter/~/~
    [
        { method: "POST", resource: "/=/model/Comment/~/~" }
    ]</pre>

<p>权限规则总是由两个属性构成，一是 <code>method</code>，用于指定允许的 HTTP 方法。 一是 <code>resource</code>，用于指定允许操纵的资源（或 URI）。</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="(28155)(21152)(26435)(38480)(35268)(21017)"
>添加权限规则</a></h3>

<pre>    POST /=/role/&#60;role name&#62;/~/~</pre>

<p><i>POST content</i></p>

<pre>    [ rule1, rule2, ... ]</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Administration"
>Administration</a></h2>

<pre>    GET/POST/DELETE /=/admin/...</pre>

<p>XXX needs work...</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DATA_FORMAT"
>DATA FORMAT</a></h1>

<p>服务器返回的数据格式可以由用户通过 URL 后缀来控制。</p>

<p>支持的格式后缀为 <code>.json</code>, <code>.xml</code>, 和 <code>.yaml</code>. 它们分别对应 JSON 格式，XML/RDF 格式，和 YAML 格式。 它们的别名为 <code>.js</code>, <code>.rdf</code>, 和 <code>.yml</code>.</p>

<p>当后缀名未指定时，缺省为 <code>.json</code>。</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Parameters"
>Parameters</a></h2>

<dl>
<dt><a name="charset"
>charset</a></dt>

<dd>
<p>指定输入／输出数据和 URL 本身所使用的字符集。</p>

<p>示例：</p>

<pre>    GET /=/model/Bookmark/title/Yahoo?charset=GBK</pre>

<dt><a name="offset"
>offset</a></dt>

<dd>
<p>该选项仅作用于 GET 请求返回列表的情形。它用于指定在返回的列表中跳过起始的记录的数目。例如</p>

<pre>    GET /=/model/Foo/~/~?offset=10</pre>

<p>将返回第十一条及其以后的记录列表。<code>offset</code> 多与 <code>count</code> 选项一起使用，以实现分页功能。</p>

<dt><a name="limit"
>limit
<dt><a name="count"
>count</a></dt>

<dd>
<p>该选项仅作用于 GET 请求返回列表的情形。它用于指定返回的条目数，缺省为 500。最大值亦为 500。</p>

<p>示例：</p>

<pre>   GET /=/model/Postbook/body/People?count=20</pre>

<p>count 的取值须为小于上限的正整数，否则服务器将报错。</p>

<p><code>limit</code> 参数为 <code>count</code> 的一个别名。</p>

<dt><a name="order_by"
>order_by</a></dt>

<dd>
<p>指定排序项（可指定多个，以逗号分隔). 例如：</p>

<pre>    GET /=/model/Bookmark/title/Yahoo?op=contains&#38;order_by=title:asc,url:desc</pre>

<p>在语义上近似于下面这条 SQL 语句：</p>

<pre>    select *
    from bookmarks
    where title like '%Yahoo%'
    order by title asc , url desc</pre>

<p>升降序的缺省是 SQL 标准的缺省：ASC。当字段中无冒号分隔的升降序声明的时候，就是升序。</p>

<dt><a name="user"
>user</a></dt>

<dd>
<p>该选项指定用户名</p>

<dt><a name="password"
>password</a></dt>

<dd>
<p>该选项指定密码</p>

<p>示例</p>

<pre>    GET /=/model/Bookmark/id.xml?user=foo&#38;password=bar</pre>

<p>注：以明文方式传递用户名和密码在安全性较高的场合是不允许使用的。</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="ERROR_HANDLING"
>ERROR HANDLING</a></h1>

<p>XXX Needs work...</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="GRAMMAR_FOR_miniSQL"
>GRAMMAR FOR miniSQL</a></h1>

<p>miniSQL 语言是标准 SQL 一个核心子集. 其基本语法如下：</p>

<pre>    miniSQL: statement

    statement: select_stmt
             | update_stmt
             | delete_stmt

    select_stmt: "select" pattern_list "from" models postfix_clause_list
               | "select" pattern_list "from" models

    pattern_list: pattern "," pattern_list
                | pattern

    pattern: aggregate alias
           | aggregate
           | column

    aggregate: func "(" column ")"
    func: "max"
        | "min"
        | "count"
        | "sum"

    column: qualified_symbol
          | symbol
    qualified_symbol: symbol "." symbol
    symbol: /[A-Za-z]+/

    alias: symbol

    postfix_clause_list: postfix_clause postfix_clause_list
                       | postfix_clause

    postfix_clause: where_clause
                  | group_by_clause
                  | order_by_clause

    where_clause: "where" condition

    condition: disjunction
    disjunction: conjunction "or" disjuntion
               | conjunction
    conjunction: comparison "and" conjunction
               | comparison
    comparison: column operator literal
              | column operator column
              | "(" condition ")"

    operator: "&#62;"
            | "&#62;="
            | "&#60;"
            | "&#60;="
            | "&#60;&#62;"
            | "="
            | "like"

    literal: string
           | integer
    string: '"' symbol '"'
          | "'" symbol "'"
    integer: /\d+/

    group_by_clause: "group by" column_list

    column_list: column "," column_list
               | column

    order_by_clause: "order by" column_list

    delete_stmt: "delete" "from" symbol where_clause
    update_stmt: "update" symbol set_clause where_clause
               | "update" symbol set_clause

    set_clause: "set" symbol "=" literal</pre>

<!-- end doc -->

</body></html>
